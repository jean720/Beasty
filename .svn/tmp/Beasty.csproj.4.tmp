<<<<<<< .working
ï»¿<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
  <PropertyGroup>
    <ProjectGuid>{5360BC71-9F95-4FB4-9576-B7385C373945}</ProjectGuid>
    <ProjectTypeGuids>{6D335F3A-9D43-41b4-9D22-F6F17C4BE596};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Beasty</RootNamespace>
    <AssemblyName>Beasty</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <XnaFrameworkVersion>v3.1</XnaFrameworkVersion>
    <XnaPlatform>Windows</XnaPlatform>
    <XnaCrossPlatformGroupID>16d6e175-0fb1-455f-9680-0ab6816c82a4</XnaCrossPlatformGroupID>
    <ApplicationIcon>Game.ico</ApplicationIcon>
    <Thumbnail>GameThumbnail.png</Thumbnail>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\x86\Debug</OutputPath>
    <DefineConstants>DEBUG;TRACE;WINDOWS</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <NoStdLib>true</NoStdLib>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <PlatformTarget>x86</PlatformTarget>
    <XnaCompressContent>false</XnaCompressContent>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\x86\Release</OutputPath>
    <DefineConstants>TRACE;WINDOWS</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <NoStdLib>true</NoStdLib>
    <UseVSHostingProcess>false</UseVSHostingProcess>
    <PlatformTarget>x86</PlatformTarget>
    <XnaCompressContent>true</XnaCompressContent>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.Xna.Framework, Version=3.1.0.0, Culture=neutral, PublicKeyToken=6d5c3888ef60e27d" />
    <Reference Include="Microsoft.Xna.Framework.Game, Version=3.1.0.0, Culture=neutral, PublicKeyToken=6d5c3888ef60e27d" />
    <Reference Include="mscorlib">
      <Private>False</Private>
    </Reference>
    <Reference Include="System">
      <Private>False</Private>
    </Reference>
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml">
      <Private>False</Private>
    </Reference>
    <Reference Include="System.Core">
      <RequiredTargetFramework>3.5</RequiredTargetFramework>
      <Private>False</Private>
    </Reference>
    <Reference Include="System.Xml.Linq">
      <RequiredTargetFramework>3.5</RequiredTargetFramework>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="BaseUnit.cs" />
    <Compile Include="Collider.cs" />
    <Compile Include="Enhancement.cs" />
    <Compile Include="DisplayGrid.cs" />
    <Compile Include="Land\LandSample.cs" />
    <Compile Include="ParticleEmitter.cs" />
    <Compile Include="Particles.cs" />
    <Compile Include="ParticleSettings.cs" />
    <Compile Include="ParticleSystem.cs" />
    <Compile Include="ParticleSystems\ExplosionParticleSystem.cs" />
    <Compile Include="ParticleSystems\ExplosionSmokeParticleSystem.cs" />
    <Compile Include="ParticleSystems\FireParticleSystem.cs" />
    <Compile Include="ParticleSystems\ProjectileTrailParticleSystem.cs" />
    <Compile Include="ParticleSystems\SmokePlumeParticleSystem.cs" />
    <Compile Include="ParticleVertex.cs" />
    <Compile Include="Projectile.cs" />
    <Compile Include="Projectiles\Bullet.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Core.cs" />
    <Compile Include="QuaternionCam.cs" />
    <Compile Include="UnitFactory.cs" />
    <Compile Include="Units\Pigeon.cs" />
    <Compile Include="Units\Tank.cs" />
    <Compile Include="Units\Box.cs" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="Game.ico" />
    <Content Include="GameThumbnail.png" />
  </ItemGroup>
  <ItemGroup>
    <NestedContentProject Include="Content\Content.contentproj">
      <Project>3e4c611d-012c-4e03-8fb7-d5b175204772</Project>
      <Visible>False</Visible>
    </NestedContentProject>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 2.0 %28x86%29</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.0 %28x86%29</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
      <Visible>False</Visible>
      <ProductName>Windows Installer 3.1</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Xna.Framework.3.1">
      <Visible>False</Visible>
      <ProductName>Microsoft XNA Framework Redistributable 3.1</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <Import Project="$(MSBuildExtensionsPath)\Microsoft\XNA Game Studio\Microsoft.Xna.GameStudio.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>=======
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Net;
using Microsoft.Xna.Framework.Storage;

namespace Beasty
{

    /// <summary>
    /// This is the main type for your game
    /// </summary>
    public class Core : Microsoft.Xna.Framework.Game
    {
        GraphicsDevice device;
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        //Particles
        Particles explosionParticle;

        // The aspect ratio determines how to scale 3d to 2d projection.
        float aspectRatio;

        GamePadState lastGamePadState = new GamePadState();
        GamePadState currentGamePadState = new GamePadState();

        SpriteFont msgFont;
        Vector2 msgFontPos;

        private bool paused = false;

        // a list of controllers
        private List<Controller> controllers = new List<Controller>();

        // list of drawable units, projectiles, misc.
        private List<BaseUnit> units = new List<BaseUnit>();
        private List<BaseUnit> projectiles = new List<BaseUnit>();

        // Grid and boundary
        private DisplayGrid grid;       

        // A shared random number generator
        private static Random random = new Random();
        public static Random Random
        {
            get { return random; }
        }

        public Core()
        {
            graphics = new GraphicsDeviceManager(this);
            //TODO double buffering
            graphics.PreferredBackBufferWidth = 853;
            graphics.PreferredBackBufferHeight = 480;
            graphics.PreferMultiSampling = true;
            /**
            graphics.PreparingDeviceSettings +=
                  new EventHandler<PreparingDeviceSettingsEventArgs>(
                      graphics_PreparingDeviceSettings);
            **/
            Content.RootDirectory = "Content";
        }

        #region Preparing for Anti-Aliasing
        private void graphics_PreparingDeviceSettings(object sender, PreparingDeviceSettingsEventArgs e)
        {
            // Xbox 360 and most PCs support FourSamples/0 
            // (4x) and TwoSamples/0 (2x) antialiasing.
            PresentationParameters pp = e.GraphicsDeviceInformation.PresentationParameters;
#if XBOX
            pp.MultiSampleQuality = 0;
            pp.MultiSampleType = MultiSampleType.FourSamples;
            return;
#else
            int quality = 0;
            GraphicsAdapter adapter = e.GraphicsDeviceInformation.Adapter;
            SurfaceFormat format = adapter.CurrentDisplayMode.Format;
            // Check for 4xAA
            if (adapter.CheckDeviceMultiSampleType(DeviceType.Hardware, format,
                false, MultiSampleType.FourSamples, out quality))
            {
                // even if a greater quality is returned, we only want quality 0
                pp.MultiSampleQuality = 0;
                pp.MultiSampleType =
                    MultiSampleType.FourSamples;
            }
            // Check for 2xAA
            else if (adapter.CheckDeviceMultiSampleType(DeviceType.Hardware,
                format, false, MultiSampleType.TwoSamples, out quality))
            {
                // even if a greater quality is returned, we only want quality 0
                pp.MultiSampleQuality = 0;
                pp.MultiSampleType =
                    MultiSampleType.TwoSamples;
            }
            return;
#endif
        }
        #endregion

        /// <summary>
        /// Allows the game to perform any initialization it needs to before starting to run.
        /// This is where it can query for any required services and load any non-graphic
        /// related content.  Calling base.Initialize will enumerate through any components
        /// and initialize them as well.
        /// </summary>
        protected override void Initialize()
        {
            device = graphics.GraphicsDevice;
            explosionParticle = new Particles("particles//explosion", "particles//explosionEffect", Content, device);

            

            base.Initialize();
        }

        /// <summary>
        /// LoadContent will be called once per game and is the place to load
        /// all of your content.
        /// </summary>
        /// 
        protected override void LoadContent()
        {
            // Create a new SpriteBatch, which can be used to draw textures.
            spriteBatch = new SpriteBatch(GraphicsDevice);
            aspectRatio = graphics.GraphicsDevice.Viewport.AspectRatio;

            // Load font for messages
            msgFont = this.Content.Load<SpriteFont>("msg");
            msgFontPos = new Vector2(graphics.GraphicsDevice.Viewport.Width / 2,
                graphics.GraphicsDevice.Viewport.Height / 2);

            // TODO: Menu system for creating units
            // create factory to produce units
            AbstractUnitFactory factory = new ConcreteUnitFactory(Content, units, projectiles);

            // create our two units
            factory.CreateUnit(UnitType.Pigeon, new Vector2(-700, 100));
            factory.CreateUnit(UnitType.Tank, new Vector2(700, 100));

            // TODO: refactor, this is a little magical
            Controller p1 = new Controller(PlayerIndex.One, units[0]);
            controllers.Add(p1);

            grid = new DisplayGrid(GraphicsDevice);
 
        }

        /// <summary>
        /// UnloadContent will be called once per game and is the place to unload
        /// all content.
        /// </summary>
        protected override void UnloadContent()
        {
            // TODO: Unload any non ContentManager content here
        }

        /// <summary>
        /// Allows the game to run logic such as updating the world,
        /// checking for collisions, gathering input, and playing audio.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Update(GameTime gameTime)
        {
            KeyboardState keyState = Keyboard.GetState();

            if (keyState.IsKeyDown(Keys.Space))
                explosionParticle.CreateExplosionVertices((float)gameTime.TotalGameTime.TotalMilliseconds);

            #region Keyboard Control
            if (keyState.IsKeyDown(Keys.W)) { units[0].Move(new Vector2(0, 1)); }
            if (keyState.IsKeyDown(Keys.S)) { units[0].Move(new Vector2(0, -1)); }
            if (keyState.IsKeyDown(Keys.A)) { units[0].Move(new Vector2(-1, 0)); }
            if (keyState.IsKeyDown(Keys.D)) { units[0].Move(new Vector2(1, 0)); }

            if (keyState.IsKeyDown(Keys.Q)) { units[0].Fire(); }

            if (keyState.IsKeyDown(Keys.Up)) { units[1].Move(new Vector2(0, 1)); }
            if (keyState.IsKeyDown(Keys.Down)) { units[1].Move(new Vector2(0, -1)); }
            if (keyState.IsKeyDown(Keys.Left)) { units[1].Move(new Vector2(-1, 0)); }
            if (keyState.IsKeyDown(Keys.Right)) { units[1].Move(new Vector2(1, 0)); }

            if (keyState.IsKeyDown(Keys.Escape))
            {
                foreach (BaseUnit unit in units) { unit.Reset(); }
            }
            #endregion

            #region Gamepad Control
            paused = false;
            foreach (Controller controller in controllers)
            {
                if (controller.Update() == ControlState.Exit) this.Exit();
                if (controller.paused) paused = true;
            }
            #endregion

            #region Units and Camera Update
            // Updates each unit
            if (!paused)
            {
                if (projectiles.Count > 0)
                {
                    projectiles.RemoveAll(i => i.life <= 0);

                    foreach (BaseUnit projectile in projectiles)
                    { projectile.Update(gameTime); }
                }

                foreach (BaseUnit unit in units)
                { unit.Update(gameTime); }

                // HAHA, ridiculous, no sense of momentum >__<
                // try using p=mv to conserve momentum, mmmmkay?
                if (Collider.collides(this.units[0], this.units[1]))
                {
                    this.units[0].Collide(this.units[1]);
                    this.units[1].Collide(this.units[0]);
                }

                base.Update(gameTime);


                cameraPosition.Z = Math.Min(7000f, Math.Max(1000f,
                    Vector2.Distance(units[0].position, units[1].position) * 1.2f));
                cameraLookAt.X = (units[0].position.X + units[1].position.X) / 2;
                cameraLookAt.Y = (units[0].position.Y + units[1].position.Y) / 2;
                cameraPosition.X = cameraLookAt.X;
                cameraPosition.Y = cameraLookAt.Y;
            }
            #endregion
        }

        /// <summary>
        /// This is called when the game should draw itself.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        /// 

        // Set the position of the camera in world space, for our view matrix.
        Vector3 cameraPosition = new Vector3(0f, 50f, 5000f);
        Vector3 cameraLookAt = new Vector3();
        ///------------------

        protected override void Draw(GameTime gameTime)
        {
            if (controllers.Exists(i => i.disconnected))
            {
                spriteBatch.Begin(SpriteBlendMode.AlphaBlend, SpriteSortMode.BackToFront, SaveStateMode.SaveState);
                string output = "Please reconnect the Game Pad";

                Vector2 FontOrigin = msgFont.MeasureString(output) / 2;
                spriteBatch.DrawString(msgFont, output, msgFontPos, Color.LightGreen,
                    0, FontOrigin, 1.0f, SpriteEffects.None, 0.5f);

                spriteBatch.End();
                paused = true;
            }
            else if (paused)
            {
                spriteBatch.Begin(SpriteBlendMode.AlphaBlend, SpriteSortMode.BackToFront, SaveStateMode.SaveState);
                string output = "Game is Paused";

                Vector2 FontOrigin = msgFont.MeasureString(output) / 2;
                spriteBatch.DrawString(msgFont, output, msgFontPos, Color.LightGreen,
                    0, FontOrigin, 1.0f, SpriteEffects.None, 0.5f);

                spriteBatch.End();
            }

            {

                GraphicsDevice.Clear(Color.CornflowerBlue);

                Matrix view = Matrix.CreateLookAt(
                    cameraPosition,
                    cameraLookAt,
                    Vector3.Up);

                Matrix projection = Matrix.CreatePerspectiveFieldOfView(
                    MathHelper.ToRadians(45.0f),
                    aspectRatio, 1.0f, 50000.0f);

                // draw each unit
                foreach (BaseUnit unit in this.units)
                { unit.Draw(projection, view); }

                foreach (BaseUnit projectile in this.projectiles)
                { projectile.Draw(projection, view); }

                grid.Draw(projection, view);

                explosionParticle.DrawExplosion(gameTime);

                base.Draw(gameTime);
            }
        }
    }
}
>>>>>>> .merge-right.r58
